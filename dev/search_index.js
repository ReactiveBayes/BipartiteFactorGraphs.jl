var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Performance-Benchmarks","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"BipartiteFactorGraphs.jl is designed for high performance. This page summarizes benchmark results and performance characteristics.","category":"page"},{"location":"benchmarks/#Benchmark-Overview","page":"Performance Benchmarks","title":"Benchmark Overview","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"The benchmarks measure the performance of BipartiteFactorGraphs.jl for various operations across different graph sizes and densities. The benchmark suite evaluates:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Graph creation: Creating empty graphs and building graphs of different sizes\nBulk operations: Adding many nodes and edges at once\nIteration: Traversing variables, factors, and their neighbors\nRandom access: Accessing node and edge data randomly\nQueries: Performance of different graph queries","category":"page"},{"location":"benchmarks/#Running-Benchmarks","page":"Performance Benchmarks","title":"Running Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"You can run the benchmarks yourself using:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"make benchmark","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"To compare benchmark results against a specific branch:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"make benchmark-compare branch=main","category":"page"},{"location":"benchmarks/#Benchmark-Configuration","page":"Performance Benchmarks","title":"Benchmark Configuration","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Benchmarks are run with the following configurations:","category":"page"},{"location":"benchmarks/#Graph-Sizes","page":"Performance Benchmarks","title":"Graph Sizes","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Small: 100 variables, 50 factors\nMedium: 1,000 variables, 500 factors\nLarge: 10,000 variables, 5,000 factors","category":"page"},{"location":"benchmarks/#Edge-Densities","page":"Performance Benchmarks","title":"Edge Densities","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Sparse: Average of 2 connections per node\nMedium: Average of 5 connections per node\nDense: Average of 10 connections per node","category":"page"},{"location":"benchmarks/#Latest-Results","page":"Performance Benchmarks","title":"Latest Results","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Below are the latest benchmark results, showing median times for key operations:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Operation Small Graph (ms) Medium Graph (ms) Large Graph (ms)\nCreate empty graph 0.001 0.001 0.001\nAdd 1 variable 0.001 0.001 0.001\nAdd 1 factor 0.001 0.001 0.001\nBuild sparse graph 0.5 5.0 50.0\nBuild medium graph 1.0 10.0 100.0\nBuild dense graph 2.0 20.0 200.0\nIterate all variables 0.001 0.01 0.1\nIterate all factors 0.001 0.005 0.05\nGet variable neighbors 0.001 0.002 0.002\nGet factor neighbors 0.001 0.002 0.002\nAccess variable data 0.001 0.001 0.001\nAccess factor data 0.001 0.001 0.001\nAccess edge data 0.001 0.001 0.001","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Note: These values are placeholders. For actual benchmark results, run the benchmarks on your system.","category":"page"},{"location":"benchmarks/#Scaling-Behavior","page":"Performance Benchmarks","title":"Scaling Behavior","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"BipartiteFactorGraphs.jl is designed to scale well with graph size and density:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Graph creation: Scales linearly with the number of nodes and edges\nNode access: Constant time regardless of graph size\nEdge access: Constant time regardless of graph size\nNeighbor iteration: Scales linearly with the number of neighbors","category":"page"},{"location":"benchmarks/#Performance-Tips","page":"Performance Benchmarks","title":"Performance Tips","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"For optimal performance with BipartiteFactorGraphs.jl:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Type stability: Always provide concrete types when creating a BipartiteFactorGraph\nDictionary choice: For very large graphs, consider using specialized dictionary types\nSpecialized queries: Use the specialized neighbor functions (variable_neighbors, factor_neighbors) rather than general neighbors and filtering\nPreallocation: Preallocate arrays when performing operations on many nodes","category":"page"},{"location":"benchmarks/#Comparison-to-Alternative-Implementations","page":"Performance Benchmarks","title":"Comparison to Alternative Implementations","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"BipartiteFactorGraphs.jl offers superior performance compared to generic graph implementations when working with bipartite factor graphs:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"More efficient storage of factor and variable data\nSpecialized functions optimized for bipartite operations\nType stability for better compiler optimization\nMinimal memory overhead","category":"page"},{"location":"benchmarks/#Benchmark-Details","page":"Performance Benchmarks","title":"Benchmark Details","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"For more details on the benchmarking methodology, see the benchmark code in the benchmark/ directory of the repository. ","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#BipartiteFactorGraphs.BipartiteFactorGraph","page":"API Reference","title":"BipartiteFactorGraphs.BipartiteFactorGraph","text":"BipartiteFactorGraph{TVar,TFac,E,DVars<:AbstractDict{Int,TVar},DFacs<:AbstractDict{Int,TFac},DE<:AbstractDict{Tuple{Int,Int},E}}\n\nA type-stable bipartite factor graph implementation that stores data for variables, factors, and edges. Users are responsible for maintaining the bipartite structure.\n\nAfter the graph is constructed, the user can use Graphs.is_bipartite(graph.graph) to check if the graph is actually bipartite. Certain functions may work incorrectly and produce unexpected results if the underlying graph is not bipartite.\n\nFields\n\ngraph::SimpleGraph{Int}: The underlying graph structure\nvariable_data::DVars: Data for variable nodes\nfactor_data::DFacs: Data for factor nodes\nedge_data::DE: Data for edges between variables and factors\n\n\n\n\n\n","category":"type"},{"location":"api/#Graph-Construction","page":"API Reference","title":"Graph Construction","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Functions for creating and modifying graphs:","category":"page"},{"location":"api/#BipartiteFactorGraphs.add_variable!","page":"API Reference","title":"BipartiteFactorGraphs.add_variable!","text":"add_variable!(g::BipartiteFactorGraph{TVar}, data::TVar) where {TVar}\n\nAdd a variable node to the graph with associated data and return its ID.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.add_factor!","page":"API Reference","title":"BipartiteFactorGraphs.add_factor!","text":"add_factor!(g::BipartiteFactorGraph{TVar,TFac}, data::TFac) where {TVar,TFac}\n\nAdd a factor node to the graph with associated data and return its ID.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.SimpleGraphs.add_edge!","page":"API Reference","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(g::BipartiteFactorGraph{TVar,TFac,E}, var::Int, fac::Int, data::E) where {TVar,TFac,E}\n\nAdd an edge between variable node var and factor node fac with associated data. User must ensure that var is a variable node and fac is a factor node. Edge data is stored with the original order of vertices (var, fac), but can be accessed in either order using getedgedata.\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-Access","page":"API Reference","title":"Data Access","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Retrieve data associated with nodes and edges:","category":"page"},{"location":"api/#BipartiteFactorGraphs.get_variable_data","page":"API Reference","title":"BipartiteFactorGraphs.get_variable_data","text":"get_variable_data(g::BipartiteFactorGraph{TVar}, v::Int) where {TVar}\n\nGet data associated with variable node v.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.get_factor_data","page":"API Reference","title":"BipartiteFactorGraphs.get_factor_data","text":"get_factor_data(g::BipartiteFactorGraph{TVar,TFac}, v::Int) where {TVar,TFac}\n\nGet data associated with factor node v.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.get_edge_data","page":"API Reference","title":"BipartiteFactorGraphs.get_edge_data","text":"get_edge_data(g::BipartiteFactorGraph{TVar,TFac,E}, v1::Int, v2::Int) where {TVar,TFac,E}\n\nGet data associated with edge between nodes v1 and v2. Since the graph is undirected, the order of v1 and v2 doesn't matter.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Query-Functions","page":"API Reference","title":"Graph Query Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Functions that query the structure of the bipartite factor graph:","category":"page"},{"location":"api/#BipartiteFactorGraphs.is_variable","page":"API Reference","title":"BipartiteFactorGraphs.is_variable","text":"is_variable(g::BipartiteFactorGraph, v::Int)\n\nCheck if node v is a variable node.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.is_factor","page":"API Reference","title":"BipartiteFactorGraphs.is_factor","text":"is_factor(g::BipartiteFactorGraph, v::Int)\n\nCheck if node v is a factor node.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.variables","page":"API Reference","title":"BipartiteFactorGraphs.variables","text":"variables(g::BipartiteFactorGraph)\n\nGet all variable nodes in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.factors","page":"API Reference","title":"BipartiteFactorGraphs.factors","text":"factors(g::BipartiteFactorGraph)\n\nGet all factor nodes in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.variable_neighbors","page":"API Reference","title":"BipartiteFactorGraphs.variable_neighbors","text":"variable_neighbors(g::BipartiteFactorGraph, v::Int)\n\nGet all variable neighbors of factor node v. Returns only neighbors that are variable nodes. Note that this is equivalent to neighbors(g, v) with extra check that the node is a factor. Use neighbors(g, v) for a version that does not check the node type.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.factor_neighbors","page":"API Reference","title":"BipartiteFactorGraphs.factor_neighbors","text":"factor_neighbors(g::BipartiteFactorGraph, v::Int)\n\nGet all factor neighbors of variable node v. Returns only neighbors that are factor nodes. Note that this is equivalent to neighbors(g, v) with extra check that the node is a variable. Use neighbors(g, v) for a version that does not check the node type.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.num_variables","page":"API Reference","title":"BipartiteFactorGraphs.num_variables","text":"num_variables(g::BipartiteFactorGraph)\n\nGet the number of variable nodes in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.num_factors","page":"API Reference","title":"BipartiteFactorGraphs.num_factors","text":"num_factors(g::BipartiteFactorGraph)\n\nGet the number of factor nodes in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Properties","page":"API Reference","title":"Graph Properties","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Functions that compute properties of the graph:","category":"page"},{"location":"api/#Graphs.nv","page":"API Reference","title":"Graphs.nv","text":"nv(g::BipartiteFactorGraph)\n\nReturn the total number of vertices in the graph. This is the sum of variable and factor nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.ne","page":"API Reference","title":"Graphs.ne","text":"ne(g::BipartiteFactorGraph)\n\nReturn the number of edges in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.has_edge","page":"API Reference","title":"Graphs.has_edge","text":"has_edge(g::BipartiteFactorGraph, var::Int, fac::Int)\n\nCheck if there is an edge between variable node var and factor node fac.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.neighbors","page":"API Reference","title":"Graphs.neighbors","text":"neighbors(g::BipartiteFactorGraph, v::Int)\n\nGet all neighbors of node v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.all_neighbors","page":"API Reference","title":"Graphs.all_neighbors","text":"all_neighbors(g::BipartiteFactorGraph, v::Int)\n\nReturn a list of all neighbors of vertex v in graph g. This is equivalent to neighbors(g, v) for undirected graphs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.degree","page":"API Reference","title":"Graphs.degree","text":"degree(g::BipartiteFactorGraph[, v])\n\nReturn a vector corresponding to the number of edges connected to each vertex in graph g. If v is specified, only return the degree for vertex v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.indegree","page":"API Reference","title":"Graphs.indegree","text":"indegree(g::BipartiteFactorGraph[, v])\n\nFor BipartiteFactorGraph this is identical to degree since the graph is undirected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.outdegree","page":"API Reference","title":"Graphs.outdegree","text":"outdegree(g::BipartiteFactorGraph[, v])\n\nFor BipartiteFactorGraph this is identical to degree since the graph is undirected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.density","page":"API Reference","title":"Graphs.density","text":"density(g::BipartiteFactorGraph)\n\nReturn the density of the graph. \n\nFor bipartite graphs, density is defined as the ratio of the number of  actual edges to the maximum possible number of edges between variable and factor nodes (which is numvariables(g) * numfactors(g)).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"usage/#Usage-Guide","page":"Usage Guide","title":"Usage Guide","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"This guide demonstrates how to use BipartiteFactorGraphs.jl effectively for different applications.","category":"page"},{"location":"usage/#Basic-Usage","page":"Usage Guide","title":"Basic Usage","text":"","category":"section"},{"location":"usage/#Creating-a-Graph","page":"Usage Guide","title":"Creating a Graph","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"First, create a bipartite factor graph with the desired data types:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"using BipartiteFactorGraphs\n\n# Create a graph with Float64 for variable data, String for factor data, \n# and Int for edge data\ng = BipartiteFactorGraph{Float64, String, Int}()","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"The type parameters specify:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"The type for variable node data\nThe type for factor node data\nThe type for edge data","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"You can use any Julia type for these parameters, including custom types.","category":"page"},{"location":"usage/#Adding-Nodes","page":"Usage Guide","title":"Adding Nodes","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Add variable and factor nodes with their associated data:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"# Add variables\nv1 = add_variable!(g, 1.0)  # returns vertex ID 1\nv2 = add_variable!(g, 2.0)  # returns vertex ID 2\n\n# Add factors\nf1 = add_factor!(g, \"sum\")  # returns vertex ID 3\nf2 = add_factor!(g, \"product\")  # returns vertex ID 4","category":"page"},{"location":"usage/#Connecting-Nodes","page":"Usage Guide","title":"Connecting Nodes","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Connect variable and factor nodes with edges containing data:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"# Connect variables and factors\nadd_edge!(g, v1, f1, 10)  # Add edge between variable v1 and factor f1 with data 10\nadd_edge!(g, v2, f1, 20)\nadd_edge!(g, v2, f2, 30)","category":"page"},{"location":"usage/#Querying-the-Graph","page":"Usage Guide","title":"Querying the Graph","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"# Get all variables and factors\nall_vars = collect(variables(g))\nall_factors = collect(factors(g))\n\n# Check node types\nprintln(is_variable(g, v1))  # true\nprintln(is_factor(g, f1))    # true\n\n# Get neighbors\nvar_neighbors = variable_neighbors(g, f1)  # Get variable neighbors of factor f1\nfac_neighbors = factor_neighbors(g, v2)    # Get factor neighbors of variable v2\n\n# Count nodes\nprintln(\"Variables: \", num_variables(g))\nprintln(\"Factors: \", num_factors(g))\n\n# Get data\nvar_data = get_variable_data(g, v1)  # 1.0\nfac_data = get_factor_data(g, f1)    # \"sum\"\nedge_data = get_edge_data(g, v1, f1) # 10","category":"page"},{"location":"usage/#Advanced-Usage","page":"Usage Guide","title":"Advanced Usage","text":"","category":"section"},{"location":"usage/#Custom-Data-Types","page":"Usage Guide","title":"Custom Data Types","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"You can use custom types for variables, factors, and edges:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"struct VariableData\n    name::String\n    value::Float64\n    domain::Vector{Float64}\nend\n\nstruct FactorData\n    function_type::Symbol\n    parameters::Dict{Symbol, Any}\nend\n\nstruct EdgeData\n    weight::Float64\n    metadata::Dict{Symbol, Any}\nend\n\n# Create graph with custom types\ng = BipartiteFactorGraph{VariableData, FactorData, EdgeData}()\n\n# Add variable with custom data\nvar_data = VariableData(\"x1\", 0.5, [-1.0, 1.0])\nv1 = add_variable!(g, var_data)\n\n# Add factor with custom data\nfactor_data = FactorData(:gaussian, Dict(:mean => 0.0, :variance => 1.0))\nf1 = add_factor!(g, factor_data)\n\n# Add edge with custom data\nedge_data = EdgeData(1.0, Dict(:message => \"hello\"))\nadd_edge!(g, v1, f1, edge_data)","category":"page"},{"location":"usage/#Using-a-Different-Dictionary-Type","page":"Usage Guide","title":"Using a Different Dictionary Type","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"By default, BipartiteFactorGraph uses Dict to store node and edge data. You can specify a different dictionary type:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"using Dictionaries  # Make sure to add this package to your project\n\n# Create a graph using Dictionaries.jl\ng = BipartiteFactorGraph{Float64, String, Int}(Dictionary)","category":"page"},{"location":"usage/#Performance-Tips","page":"Usage Guide","title":"Performance Tips","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"For large graphs, consider the following performance optimizations:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Preallocate arrays when iterating over many nodes\nUse specific queries (like variable_neighbors) instead of filtering general results\nCreate separate graphs for different data domains if appropriate\nFor very large graphs, consider specialized dictionary types optimized for your use case","category":"page"},{"location":"usage/#Example:-Simple-Inference-on-a-Factor-Graph","page":"Usage Guide","title":"Example: Simple Inference on a Factor Graph","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Here's a simple example of how BipartiteFactorGraphs might be used in a belief propagation algorithm:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"using BipartiteFactorGraphs\nusing LinearAlgebra\n\n# Create a simple Gaussian factor graph\ng = BipartiteFactorGraph{Vector{Float64}, Function, Matrix{Float64}}()\n\n# Add variable nodes (mean and covariance)\nv1 = add_variable!(g, [0.0, 0.0])  # Prior belief\nv2 = add_variable!(g, [0.0, 0.0])  # Prior belief\n\n# Add factor nodes (functions that compute messages)\nf_prior = add_factor!(g, x -> exp(-0.5 * dot(x, x)))  # Prior factor (zero mean, unit covariance)\nf_likelihood = add_factor!(g, (x, y) -> exp(-0.5 * norm(y - x)^2))  # Likelihood factor\n\n# Add edges with covariances\nadd_edge!(g, v1, f_prior, Matrix(1.0I, 2, 2))\nadd_edge!(g, v1, f_likelihood, Matrix(1.0I, 2, 2))\nadd_edge!(g, v2, f_likelihood, Matrix(1.0I, 2, 2))\n\n# Perform simple message passing (in a real implementation, this would be more complex)\nfunction update_beliefs!(g)\n    # Update variable beliefs based on connected factors\n    for v in variables(g)\n        factors = factor_neighbors(g, v)\n        new_belief = zeros(length(get_variable_data(g, v)))\n        \n        for f in factors\n            # In a real implementation, compute messages from factors\n            # Here we just illustrate the pattern\n            factor_fn = get_factor_data(g, f)\n            edge_info = get_edge_data(g, v, f)\n            \n            # Update beliefs using the factor and edge data\n            # (simplified for illustration)\n            new_belief += edge_info * ones(size(edge_info, 1))\n        end\n        \n        # In a real implementation, we would update the variable data here\n        println(\"New belief for variable $v: $new_belief\")\n    end\nend\n\n# Run one iteration of belief update\nupdate_beliefs!(g)","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"","category":"page"},{"location":"#BipartiteFactorGraphs.jl","page":"Home","title":"BipartiteFactorGraphs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A performant implementation of bipartite factor graphs in Julia","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BipartiteFactorGraphs.jl provides a type-stable implementation of bipartite factor graphs built on top of Graphs.jl. The package is designed for high performance while maintaining a clean, intuitive API.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bipartite factor graphs are a specialized type of graph where nodes are divided into two distinct sets:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Variable nodes: Represent variables in a probabilistic model\nFactor nodes: Represent relationships or constraints between variables","category":"page"},{"location":"","page":"Home","title":"Home","text":"This structure is particularly useful for probabilistic graphical models, Bayesian inference, message passing algorithms, factor graph algorithms, and more.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Type-stable implementation with parametric types for variables, factors, and edges\nEfficient data storage and retrieval for node and edge properties\nSpecialized query functions for bipartite factor graphs\nCompatible with the Graphs.jl ecosystem","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"BipartiteFactorGraphs\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using BipartiteFactorGraphs\n\n# Create a graph with Float64 variable data, String factor data, and Int edge data\ng = BipartiteFactorGraph{Float64, String, Int}()\n\n# Add variables\nv1 = add_variable!(g, 1.0)\nv2 = add_variable!(g, 2.0)\nv3 = add_variable!(g, 3.0)\n\n# Add factors\nf1 = add_factor!(g, \"sum\")\nf2 = add_factor!(g, \"product\")\n\n# Connect variables and factors with edges\nadd_edge!(g, v1, f1, 10)\nadd_edge!(g, v2, f1, 20)\nadd_edge!(g, v2, f2, 30)\nadd_edge!(g, v3, f2, 40)\n\n# Query the graph\nprintln(\"Number of variables: \", num_variables(g))\nprintln(\"Number of factors: \", num_factors(g))\nprintln(\"Neighbors of factor f1: \", variable_neighbors(g, f1))\nprintln(\"Edge data between v2 and f1: \", get_edge_data(g, v2, f1))","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"usage.md\",\n    \"api.md\",\n    \"benchmarks.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
