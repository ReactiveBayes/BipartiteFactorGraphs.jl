var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Performance-Benchmarks","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"BipartiteFactorGraphs.jl is designed for high performance. This page summarizes benchmark results and performance characteristics.","category":"page"},{"location":"benchmarks/#Benchmark-Overview","page":"Performance Benchmarks","title":"Benchmark Overview","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"The benchmarks measure the performance of BipartiteFactorGraphs.jl for various operations across different graph sizes and densities. The benchmark suite evaluates:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Graph creation: Creating empty graphs and building graphs of different sizes\nBulk operations: Adding many nodes and edges at once\nIteration: Traversing variables, factors, and their neighbors\nRandom access: Accessing node and edge data randomly\nQueries: Performance of different graph queries","category":"page"},{"location":"benchmarks/#Running-Benchmarks","page":"Performance Benchmarks","title":"Running Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"You can run the benchmarks yourself using:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"make benchmark","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"To compare benchmark results against a specific branch:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"make benchmark-compare branch=main","category":"page"},{"location":"benchmarks/#Benchmark-Configuration","page":"Performance Benchmarks","title":"Benchmark Configuration","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Benchmarks are run with the following configurations:","category":"page"},{"location":"benchmarks/#Graph-Sizes","page":"Performance Benchmarks","title":"Graph Sizes","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Small: 100 variables, 50 factors\nMedium: 1,000 variables, 500 factors\nLarge: 10,000 variables, 5,000 factors","category":"page"},{"location":"benchmarks/#Edge-Densities","page":"Performance Benchmarks","title":"Edge Densities","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Sparse: Average of 2 connections per node\nMedium: Average of 5 connections per node\nDense: Average of 10 connections per node","category":"page"},{"location":"benchmarks/#Scaling-Behavior","page":"Performance Benchmarks","title":"Scaling Behavior","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"BipartiteFactorGraphs.jl is designed to scale well with graph size and density:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Graph creation: Scales linearly with the number of nodes and edges\nNode access: Constant time regardless of graph size\nEdge access: Constant time regardless of graph size\nNeighbor iteration: Scales linearly with the number of neighbors","category":"page"},{"location":"benchmarks/#Performance-Tips","page":"Performance Benchmarks","title":"Performance Tips","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"For optimal performance with BipartiteFactorGraphs.jl:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"Type stability: Always provide concrete types when creating a BipartiteFactorGraph\nDictionary choice: For very large graphs, consider using specialized dictionary types\nSpecialized queries: Use the specialized neighbor functions (variable_neighbors, factor_neighbors) rather than general neighbors and filtering\nPreallocation: Preallocate arrays when performing operations on many nodes","category":"page"},{"location":"benchmarks/#Comparison-to-Alternative-Implementations","page":"Performance Benchmarks","title":"Comparison to Alternative Implementations","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"BipartiteFactorGraphs.jl offers superior performance compared to generic graph implementations when working with bipartite factor graphs:","category":"page"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"More efficient storage of factor and variable data\nSpecialized functions optimized for bipartite operations\nType stability for better compiler optimization\nMinimal memory overhead","category":"page"},{"location":"benchmarks/#Benchmark-Details","page":"Performance Benchmarks","title":"Benchmark Details","text":"","category":"section"},{"location":"benchmarks/","page":"Performance Benchmarks","title":"Performance Benchmarks","text":"For more details on the benchmarking methodology, see the benchmark code in the benchmark/ directory of the repository. ","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#BipartiteFactorGraphs.BipartiteFactorGraph","page":"API Reference","title":"BipartiteFactorGraphs.BipartiteFactorGraph","text":"BipartiteFactorGraph\n\nA type-stable bipartite undirected factor graph implementation that stores data for variables, factors, and edges. Users are responsible for maintaining the bipartite structure.\n\nAfter the graph is constructed, the user can use Graphs.is_bipartite(graph.graph) to check if the graph is actually bipartite. Certain functions may work incorrectly and produce unexpected results if the underlying graph is not bipartite.\n\nFields\n\ngraph: The underlying graph structure\nvariable_data: A dictionary of data for variable nodes where the keys are elements of type Int and the values are of type TVar\nfactor_data: A dictionary of data for factor nodes where the keys are elements of type Int and the values are of type TFac\nedge_data: A dictionary of data for edges between variables and factors where the keys are elements of type UnorderedPair and the values are of type E\n\nnote: Note\nEdge data keys are stored as UnorderedPairs to avoid duplicate entries or access errors.  This means that get_edge_data(g, v1, v2) is equivalent to get_edge_data(g, v2, v1). This also implies that the graph is undirected.\n\nTo construct an empty BipartiteFactorGraph with specified variable, factor and edge data types use the following constructor:\n\nBipartiteFactorGraph(::Type{TVar}, ::Type{TFac}, ::Type{E}, dict_type::Type{D}=Dict) where {TVar,TFac,E,D}\n\nArguments\n\nTVar: The type of the variable data\nTFac: The type of the factor data\nE: The type of the edge data\ndict_type: The type of the dictionary used to store the variable, factor and edge data (defaults to Base.Dict)\n\nAs an alternative to the constructor, you can use BipartiteFactorGraph() as an alias to BipartiteFactorGraph(Any, Any, Any, Dict).\n\nExample\n\njulia> g = BipartiteFactorGraph(Int, Float64, String, Dict)\nBipartiteFactorGraph{Int64, Float64, String} with 0 variables, 0 factors, and 0 edges\n\njulia> add_variable!(g, 1);\n\njulia> add_factor!(g, 2.0);\n\njulia> add_edge!(g, 1, 2, \"Hello\");\n\njulia> g\nBipartiteFactorGraph{Int64, Float64, String} with 1 variables, 1 factors, and 1 edges\n\n\n\n\n\n","category":"type"},{"location":"api/#Graph-Construction","page":"API Reference","title":"Graph Construction","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Functions for creating and modifying graphs:","category":"page"},{"location":"api/#BipartiteFactorGraphs.add_variable!","page":"API Reference","title":"BipartiteFactorGraphs.add_variable!","text":"add_variable!(g::BipartiteFactorGraph{TVar}, data::TVar) where {TVar}\n\nAdd a variable node to the graph with associated data and return its ID.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.add_factor!","page":"API Reference","title":"BipartiteFactorGraphs.add_factor!","text":"add_factor!(g::BipartiteFactorGraph{TVar,TFac}, data::TFac) where {TVar,TFac}\n\nAdd a factor node to the graph with associated data and return its ID.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.SimpleGraphs.add_edge!","page":"API Reference","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(g::BipartiteFactorGraph{TVar,TFac,E}, var::Int, fac::Int, data::E) where {TVar,TFac,E}\n\nAdd an edge between variable node var and factor node fac with associated data. User must ensure that var is a variable node and fac is a factor node. Edge data is stored with the original order of vertices (var, fac), but can be accessed in either order using getedgedata.\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-Access","page":"API Reference","title":"Data Access","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Retrieve data associated with nodes and edges:","category":"page"},{"location":"api/#BipartiteFactorGraphs.get_variable_data","page":"API Reference","title":"BipartiteFactorGraphs.get_variable_data","text":"get_variable_data(g::BipartiteFactorGraph{TVar}, v::Int) where {TVar}\n\nGet data associated with variable node v.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.get_factor_data","page":"API Reference","title":"BipartiteFactorGraphs.get_factor_data","text":"get_factor_data(g::BipartiteFactorGraph{TVar,TFac}, v::Int) where {TVar,TFac}\n\nGet data associated with factor node v.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.get_edge_data","page":"API Reference","title":"BipartiteFactorGraphs.get_edge_data","text":"get_edge_data(g::BipartiteFactorGraph{TVar,TFac,E}, v1::Int, v2::Int) where {TVar,TFac,E}\n\nGet data associated with edge between nodes v1 and v2. Since the graph is undirected, the order of v1 and v2 doesn't matter.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Query-Functions","page":"API Reference","title":"Graph Query Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Functions that query the structure of the bipartite factor graph:","category":"page"},{"location":"api/#BipartiteFactorGraphs.is_variable","page":"API Reference","title":"BipartiteFactorGraphs.is_variable","text":"is_variable(g::BipartiteFactorGraph, v::Int)\n\nCheck if node v is a variable node.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.is_factor","page":"API Reference","title":"BipartiteFactorGraphs.is_factor","text":"is_factor(g::BipartiteFactorGraph, v::Int)\n\nCheck if node v is a factor node.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.variables","page":"API Reference","title":"BipartiteFactorGraphs.variables","text":"variables(g::BipartiteFactorGraph)\n\nGet all variable nodes in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.factors","page":"API Reference","title":"BipartiteFactorGraphs.factors","text":"factors(g::BipartiteFactorGraph)\n\nGet all factor nodes in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.variable_neighbors","page":"API Reference","title":"BipartiteFactorGraphs.variable_neighbors","text":"variable_neighbors(g::BipartiteFactorGraph, v::Int)\n\nGet all variable neighbors of factor node v. Returns only neighbors that are variable nodes. Note that this is equivalent to neighbors(g, v) with extra check that the node is a factor. Use neighbors(g, v) for a version that does not check the node type.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.factor_neighbors","page":"API Reference","title":"BipartiteFactorGraphs.factor_neighbors","text":"factor_neighbors(g::BipartiteFactorGraph, v::Int)\n\nGet all factor neighbors of variable node v. Returns only neighbors that are factor nodes. Note that this is equivalent to neighbors(g, v) with extra check that the node is a variable. Use neighbors(g, v) for a version that does not check the node type.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.num_variables","page":"API Reference","title":"BipartiteFactorGraphs.num_variables","text":"num_variables(g::BipartiteFactorGraph)\n\nGet the number of variable nodes in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#BipartiteFactorGraphs.num_factors","page":"API Reference","title":"BipartiteFactorGraphs.num_factors","text":"num_factors(g::BipartiteFactorGraph)\n\nGet the number of factor nodes in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Properties","page":"API Reference","title":"Graph Properties","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Functions that compute properties of the graph:","category":"page"},{"location":"api/#Graphs.nv","page":"API Reference","title":"Graphs.nv","text":"nv(g::BipartiteFactorGraph)\n\nReturn the total number of vertices in the graph. This is the sum of variable and factor nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.ne","page":"API Reference","title":"Graphs.ne","text":"ne(g::BipartiteFactorGraph)\n\nReturn the number of edges in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.vertices","page":"API Reference","title":"Graphs.vertices","text":"vertices(g::BipartiteFactorGraph)\n\nGet all vertices in the graph. Note, that it returns vertices that represent both variable and factor nodes. Use variables and factors to get only variable or factor nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.has_vertex","page":"API Reference","title":"Graphs.has_vertex","text":"has_vertex(g::BipartiteFactorGraph, v::Int)\n\nCheck if vertex v is in the graph. Note, that it returns true for both variable and factor nodes. Use is_variable and is_factor to check existence of a node with a specific type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.has_edge","page":"API Reference","title":"Graphs.has_edge","text":"has_edge(g::BipartiteFactorGraph, var::Int, fac::Int)\n\nCheck if there is an edge between variable node var and factor node fac.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.edges","page":"API Reference","title":"Graphs.edges","text":"edges(g::BipartiteFactorGraph)\n\nGet all edges in the graph. \n\nnote: Note\nThis function behaves differently from variables and factors in that it calls Graphs.edges.  The closest equivalent for nodes is the neighbors function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.neighbors","page":"API Reference","title":"Graphs.neighbors","text":"neighbors(g::BipartiteFactorGraph, v::Int)\n\nGet all neighbors of node v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.all_neighbors","page":"API Reference","title":"Graphs.all_neighbors","text":"all_neighbors(g::BipartiteFactorGraph, v::Int)\n\nReturn a list of all neighbors of vertex v in graph g. This is equivalent to neighbors(g, v) for undirected graphs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.inneighbors","page":"API Reference","title":"Graphs.inneighbors","text":"inneighbors(g::BipartiteFactorGraph, v::Int)\n\nReturn a list of all in-neighbors of vertex v in graph g.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.outneighbors","page":"API Reference","title":"Graphs.outneighbors","text":"outneighbors(g::BipartiteFactorGraph, v::Int)\n\nReturn a list of all out-neighbors of vertex v in graph g.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.degree","page":"API Reference","title":"Graphs.degree","text":"degree(g::BipartiteFactorGraph[, v])\n\nReturn a vector corresponding to the number of edges connected to each vertex in graph g. If v is specified, only return the degree for vertex v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.indegree","page":"API Reference","title":"Graphs.indegree","text":"indegree(g::BipartiteFactorGraph[, v])\n\nFor BipartiteFactorGraph this is identical to degree since the graph is undirected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.outdegree","page":"API Reference","title":"Graphs.outdegree","text":"outdegree(g::BipartiteFactorGraph[, v])\n\nFor BipartiteFactorGraph this is identical to degree since the graph is undirected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.density","page":"API Reference","title":"Graphs.density","text":"density(g::BipartiteFactorGraph)\n\nReturn the density of the graph. \n\nFor bipartite graphs, density is defined as the ratio of the number of  actual edges to the maximum possible number of edges between variable and factor nodes (which is numvariables(g) * numfactors(g)).\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.is_bipartite","page":"API Reference","title":"Graphs.is_bipartite","text":"is_bipartite(g::BipartiteFactorGraph)\n\nCheck if the graph is bipartite.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.is_directed","page":"API Reference","title":"Graphs.is_directed","text":"is_directed(g::BipartiteFactorGraph)\n\nCheck if the graph is directed. For BipartiteFactorGraph this is always false since the graph is undirected.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"usage-basic/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"This guide demonstrates how to use BipartiteFactorGraphs.jl effectively for different applications.","category":"page"},{"location":"usage-basic/#Creating-a-Graph","page":"Basic Usage","title":"Creating a Graph","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"First, create a bipartite factor graph with the desired data types:","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"using BipartiteFactorGraphs\nusing Test #hide\n\n# Create a graph with Float64 for variable data, String for factor data, \n# and Int for edge data\ng = BipartiteFactorGraph(Float64, String, Int)\n@test g isa BipartiteFactorGraph{Float64, String, Int} #hide\n\nshow(g)","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"The type parameters specify:","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"The type for variable node data\nThe type for factor node data\nThe type for edge data","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"You can use any Julia type for these parameters, including custom types.","category":"page"},{"location":"usage-basic/#Adding-Nodes","page":"Basic Usage","title":"Adding Nodes","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"Add variable and factor nodes with their associated data using the add_variable! and add_factor! functions:","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"# Add variables\nv1 = add_variable!(g, 1.0)  # returns vertex ID 1\nv2 = add_variable!(g, 2.0)  # returns vertex ID 2\n\n# Add factors\nf1 = add_factor!(g, \"sum\")  # returns vertex ID 3\nf2 = add_factor!(g, \"product\")  # returns vertex ID 4\n\n@test length(variables(g)) == 2 #hide\n@test length(factors(g)) == 2 #hide\n@test nv(g) == 4 #hide\n\nshow(g)","category":"page"},{"location":"usage-basic/#Connecting-Nodes","page":"Basic Usage","title":"Connecting Nodes","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"Connect variable and factor nodes with edges containing data with the add_edge! function:","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"# Connect variables and factors\nadd_edge!(g, v1, f1, 10)  # Add edge between variable v1 and factor f1 with data 10\nadd_edge!(g, v2, f1, 20)\nadd_edge!(g, v2, f2, 30)\n\n@test has_edge(g, v1, f1) #hide\n@test has_edge(g, v2, f1) #hide\n@test has_edge(g, v2, f2) #hide\n@test ne(g) == 3 #hide\n@test length(edges(g)) == 3 #hide\n\nshow(g)","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"warning: Warning\nYou are responsible for maintaining the bipartite structure of the graph. The package does not prevent you from adding edges between two variables or two factors, but doing so violates the bipartite property. Always ensure that edges only connect variable nodes to factor nodes. You can use the Graphs.is_bipartite function to check if the graph is bipartite.BipartiteFactorGraphs.is_bipartite(g)Failing to ensure the bipartite property will most likely lead to wrong results or undefined behavior.","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"has_edge(g, v1, f1)","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"has_edge(g, v1, f2)","category":"page"},{"location":"usage-basic/#Querying-the-Graph","page":"Basic Usage","title":"Querying the Graph","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"BipartiteFactorGraphs.jl provides several functions to query the graph structure and retrieve information about nodes and their connections:","category":"page"},{"location":"usage-basic/#Getting-all-variable-and-associated-data","page":"Basic Usage","title":"Getting all variable and associated data","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"See variables and get_variable_data","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test Set(variables(g)) == Set([v1, v2]) #hide\n# Get all variables\nvariables(g)","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test Set(get_variable_data.(g, variables(g))) == Set([1.0, 2.0]) #hide\nget_variable_data.(g, variables(g))","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test get_variable_data(g, v1) == 1.0 #hide\nget_variable_data(g, v1)","category":"page"},{"location":"usage-basic/#Getting-all-factor-and-associated-data","page":"Basic Usage","title":"Getting all factor and associated data","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"See factors and get_factor_data","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test Set(factors(g)) == Set([f1, f2]) #hide\n# Get all factors\nfactors(g)","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test Set(get_factor_data.(g, factors(g))) == Set([\"sum\", \"product\"]) #hide\nget_factor_data.(g, factors(g))","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test get_factor_data(g, f1) == \"sum\" #hide\nget_factor_data(g, f1)","category":"page"},{"location":"usage-basic/#Checking-node-types","page":"Basic Usage","title":"Checking node types","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"See is_variable and is_factor","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test is_variable(g, v1) #hide\n@test !is_factor(g, v1) #hide\nis_variable(g, v1), is_factor(g, v1)","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test is_factor(g, f1) #hide\n@test !is_variable(g, f1) #hide\nis_factor(g, f1), is_variable(g, f1)","category":"page"},{"location":"usage-basic/#Getting-neighbors","page":"Basic Usage","title":"Getting neighbors","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"See neighbors, variable_neighbors, and factor_neighbors","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test Set(variable_neighbors(g, f1)) == Set([v1, v2]) #hide\nvariable_neighbors(g, f1)  # Get variable neighbors of factor f1","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test Set(factor_neighbors(g, v1)) == Set([f1]) #hide\nfactor_neighbors(g, v1)  # Get factor neighbors of variable v1","category":"page"},{"location":"usage-basic/#Getting-the-number-of-nodes","page":"Basic Usage","title":"Getting the number of nodes","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"See nv, num_variables, and num_factors","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test nv(g) == 4 #hide\nnv(g)","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test num_variables(g) == 2 #hide\nnum_variables(g)","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test num_factors(g) == 2 #hide\nnum_factors(g)","category":"page"},{"location":"usage-basic/#Getting-the-number-of-edges","page":"Basic Usage","title":"Getting the number of edges","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"See ne and edges","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test ne(g) == 3 #hide\nne(g)","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test length(edges(g)) == 3 #hide\nlength(edges(g))","category":"page"},{"location":"usage-basic/#Getting-data-of-edges","page":"Basic Usage","title":"Getting data of edges","text":"","category":"section"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"See get_edge_data","category":"page"},{"location":"usage-basic/","page":"Basic Usage","title":"Basic Usage","text":"@test get_edge_data(g, v1, f1) == 10 #hide\nget_edge_data(g, v1, f1)","category":"page"},{"location":"usage-advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"usage-advanced/#Custom-Data-Types","page":"Advanced Usage","title":"Custom Data Types","text":"","category":"section"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"You can use custom types for variables, factors, and edges:","category":"page"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using BipartiteFactorGraphs\nusing Test #hide\n\nstruct VariableData\n    name::String\n    value::Float64\n    domain::Vector{Float64}\nend\n\nstruct FactorData\n    function_type::Symbol\n    parameters::Dict{Symbol, Any}\nend\n\nstruct EdgeData\n    weight::Float64\n    metadata::Dict{Symbol, Any}\nend\n\n# Create graph with custom types\n@test BipartiteFactorGraph(VariableData, FactorData, EdgeData) isa BipartiteFactorGraph{VariableData, FactorData, EdgeData} #hide\ng = BipartiteFactorGraph(VariableData, FactorData, EdgeData)","category":"page"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"# Add variable with custom data\nvar_data = VariableData(\"x1\", 0.5, [-1.0, 1.0])\nv1 = add_variable!(g, var_data)\n\n# Add factor with custom data\nfactor_data = FactorData(:gaussian, Dict(:mean => 0.0, :variance => 1.0))\nf1 = add_factor!(g, factor_data)\n\n# Add edge with custom data\nedge_data = EdgeData(1.0, Dict(:message => \"hello\"))\nadd_edge!(g, v1, f1, edge_data)\n\n@test get_variable_data(g, v1) == var_data #hide\n@test get_factor_data(g, f1) == factor_data #hide\n@test get_edge_data(g, v1, f1) == edge_data #hide\n\nnothing #hide","category":"page"},{"location":"usage-advanced/#Using-a-Different-Dictionary-Type","page":"Advanced Usage","title":"Using a Different Dictionary Type","text":"","category":"section"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"By default, BipartiteFactorGraph uses Dict to store node and edge data. You can specify a different dictionary type. For example, the package implements an extension for the Dictionaries.jl package.","category":"page"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"note: Note\nDictionaries.jl do not subtype from the AbstractDict type, so internally BipartiteFactorGraph wraps the dictionary in a special wrapper type that implements the AbstractDict interface.","category":"page"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using Dictionaries  # Make sure to add this package to your project\n\n# Create a graph using Dictionaries.jl\ng = BipartiteFactorGraph(Float64, String, Int, Dictionary)","category":"page"},{"location":"usage-advanced/#Performance-Tips","page":"Advanced Usage","title":"Performance Tips","text":"","category":"section"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"For large graphs, consider the following performance optimizations:","category":"page"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Preallocate arrays when iterating over many nodes\nUse specific queries (like variable_neighbors) instead of filtering general results\nCreate separate graphs for different data domains if appropriate\nFor very large graphs, consider specialized dictionary types optimized for your use case","category":"page"},{"location":"usage-advanced/#Example:-Simple-Inference-on-a-Factor-Graph","page":"Advanced Usage","title":"Example: Simple Inference on a Factor Graph","text":"","category":"section"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Here's a simple example of how BipartiteFactorGraphs might be used in a belief propagation algorithm:","category":"page"},{"location":"usage-advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using BipartiteFactorGraphs\nusing LinearAlgebra\n\n# Create a simple Gaussian factor graph\ng = BipartiteFactorGraph(Vector{Float64}, Function, Matrix{Float64})\n\n# Add variable nodes (mean and covariance)\nv1 = add_variable!(g, [0.0, 0.0])  # Prior belief\nv2 = add_variable!(g, [0.0, 0.0])  # Prior belief\n\n# Add factor nodes (functions that compute messages)\nf_prior = add_factor!(g, x -> exp(-0.5 * dot(x, x)))  # Prior factor (zero mean, unit covariance)\nf_likelihood = add_factor!(g, (x, y) -> exp(-0.5 * norm(y - x)^2))  # Likelihood factor\n\n# Add edges with covariances\nadd_edge!(g, v1, f_prior, Matrix(1.0I, 2, 2))\nadd_edge!(g, v1, f_likelihood, Matrix(1.0I, 2, 2))\nadd_edge!(g, v2, f_likelihood, Matrix(1.0I, 2, 2))\n\n# Perform simple message passing (in a real implementation, this would be more complex)\nfunction update_beliefs!(g)\n    # Update variable beliefs based on connected factors\n    for v in variables(g)\n        factors = factor_neighbors(g, v)\n        new_belief = zeros(length(get_variable_data(g, v)))\n        \n        for f in factors\n            # In a real implementation, compute messages from factors\n            # Here we just illustrate the pattern\n            factor_fn = get_factor_data(g, f)\n            edge_info = get_edge_data(g, v, f)\n            \n            # Update beliefs using the factor and edge data\n            # (simplified for illustration)\n            new_belief += edge_info * ones(size(edge_info, 1))\n        end\n        \n        # In a real implementation, we would update the variable data here\n        println(\"New belief for variable $v: $new_belief\")\n    end\nend\n\n# Run one iteration of belief update\nupdate_beliefs!(g)\n\nnothing #hide","category":"page"},{"location":"#BipartiteFactorGraphs.jl","page":"Home","title":"BipartiteFactorGraphs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A performant implementation of bipartite factor graphs in Julia","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BipartiteFactorGraphs.jl provides a type-stable implementation of bipartite factor graphs built on top of Graphs.jl. The package is designed for high performance while maintaining a clean, intuitive API.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bipartite factor graphs are a specialized type of graph where nodes are divided into two distinct sets:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Variable nodes: Represent variables in a probabilistic model\nFactor nodes: Represent relationships or constraints between variables","category":"page"},{"location":"","page":"Home","title":"Home","text":"This structure is particularly useful for probabilistic graphical models, Bayesian inference, message passing algorithms, factor graph algorithms, and more.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Type-stable implementation with parametric types for variables, factors, and edges\nEfficient data storage and retrieval for node and edge properties\nSpecialized query functions for bipartite factor graphs\nCompatible with the Graphs.jl ecosystem","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"BipartiteFactorGraphs\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or via the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add BipartiteFactorGraphs","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a simple example demonstrating how to create and work with a bipartite factor graph:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BipartiteFactorGraphs\n\n# Create a graph with Float64 variable data, String factor data, and Int edge data\ng = BipartiteFactorGraph(Float64, String, Int)\n\n# Add variables\nv1 = add_variable!(g, 1.0)\nv2 = add_variable!(g, 2.0)\nv3 = add_variable!(g, 3.0)\n\n# Add factors\nf1 = add_factor!(g, \"sum\")\nf2 = add_factor!(g, \"product\")\n\n# Connect variables and factors with edges\nadd_edge!(g, v1, f1, 10)\nadd_edge!(g, v2, f1, 20)\nadd_edge!(g, v2, f2, 30)\nadd_edge!(g, v3, f2, 40)\n\n# Query the graph\nprintln(\"Number of variables: \", num_variables(g))\nprintln(\"Number of factors: \", num_factors(g))\nprintln(\"Neighbors of factor f1: \", variable_neighbors(g, f1))\nprintln(\"Edge data between v2 and f1: \", get_edge_data(g, v2, f1))","category":"page"},{"location":"#Where-to-go-next?","page":"Home","title":"Where to go next?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"usage.md\",\n    \"api.md\",\n    \"benchmarks.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
